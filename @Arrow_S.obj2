@矢印
--information:矢印@Arrow_S v1.00 (for beta15)
--label:Custom\図形
--track@width:幅,0,4000,300,1
--track@height:高さ,0,4000,120,1
--track@align_x:水平揃え,-100,100,0,0.001
--track@align_y:垂直揃え,-100,100,0,0.001
--track@line:ライン幅,0,4000,6,0.01
--color@color:色,0xffffff
--color@color_back:背景色,0x000000
--track@alpha_back:背景透明度,0,100,100,0.01
--track@head_len:矢じり長さ(幅に対する%),0,100,30,0.01
--track@head_width:矢じり幅(高さに対する%),0,100,100,0.01
--track@shaft:軸太さ(高さに対する%),0,100,30,0.01
--check@double_head:両端矢印,0
--value@PI:PI,{}
--[[pixelshader@combine:
Texture2D chm : register(t0);
Texture2D bkg : register(t1);
cbuffer constant0 : register(b0) { float a_back; };
float4 combine(float4 pos : SV_Position) : SV_Target {
    float4 col_bkg = bkg.Load(int3(pos.xy, 0));
    float4 col_chm = chm.Load(int3(pos.xy, 0));
    col_bkg *= a_back * max(1 - (col_bkg.a > 0 ? col_chm.a / col_bkg.a : 0), 0);
    return col_chm + col_bkg;
}
]]
--[[pixelshader@carve:
cbuffer constant0 : register(b0) {
	float2 r_hsize;     // (2/width, 2/height)
	float head_len;     // normalized length along X in [-1,1] space (0..2)
	float shaft_half;   // half thickness relative to normalized half-height (0..1)
	float head_half;    // arrowhead base half-height relative to normalized half-height (0..1)
	float double_head;  // 0 or 1
};

static float sdBox(float2 p, float2 b)
{
	float2 d = abs(p) - b;
	return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// Signed distance to isosceles triangle oriented along +Y.
// q = (base_half_width_x, height_y); base centered at (0,0), apex at (0, q.y)
static float sdIsoscelesTr(float2 p, float2 q)
{
	p.x = abs(p.x);
	float2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);
	float2 b = p - q * float2(clamp(p.x / q.x, 0.0, 1.0), 1.0);
	float s = -sign(q.y);
	float2 d = min(float2(dot(a, a), s * (p.x * q.y - p.y * q.x)),
				  float2(dot(b, b), s * (p.y - q.y)));
	return -sqrt(d.x) * sign(d.y);
}

// Arrowhead pointing to +X; length = L, base half = B.
// Expects p to be in a local frame where the base center is at (0,0) and apex at (L,0).
static float sdArrowHeadRight(float2 p, float B, float L)
{
	// swap axes to reuse upward triangle SDF: (x,y) => (y,x)
	float2 pp = float2(p.y, p.x);
	return sdIsoscelesTr(pp, float2(B, L));
}

float4 carve(float4 pos : SV_Position) : SV_Target
{
	// Normalize pixel position into [-1,1]^2 space with aspect correction.
	float2 p = r_hsize * pos.xy - 1.0;

	// Parameters in normalized space.
	float hn = saturate(head_len);            // 0..2
	float ly = saturate(shaft_half);          // 0..1 (half thickness)
	float hb = saturate(head_half);           // 0..1 (half base height)
	bool dbl = (double_head > 0.5);

	// Shaft rectangle SDF: centered differently for single vs double head.
	float sd = 1e9;
	{
		float2 center;
		float2 halfxy;
		if (dbl) {
			// shaft spans x in [-1+hn, 1-hn] => half length = 1 - hn
			center = float2(0.0, 0.0);
			halfxy = float2(max(1.0 - hn, 0.0), ly);
		} else {
			// shaft spans x in [-1, 1-hn] => center = (-hn/2, 0), half length = 1 - hn/2
			center = float2(-0.5 * hn, 0.0);
			halfxy = float2(max(1.0 - 0.5 * hn, 0.0), ly);
		}
		sd = sdBox(p - center, halfxy);
	}

	// Right head: base centered at x = 1 - hn, apex at x = 1
	{
		float2 pr = p - float2(1.0 - hn, 0.0);
		float sdr = sdArrowHeadRight(pr, hb, hn);
		sd = min(sd, sdr);
	}

	// Left head if double
	if (dbl) {
		float2 pl = float2(-p.x, p.y) - float2(1.0 - hn, 0.0);
		float sdl = sdArrowHeadRight(pl, hb, hn);
		sd = min(sd, sdl);
	}

	// Anti-aliased edge alpha from signed distance
	float w = fwidth(sd);
	float l = (w > 0.0) ? (-sd / w) : -sign(sd);
	float a = saturate(l + 0.5);
	return float4(0, 0, 0, a);
}
]]

local obj, math, tonumber, type = obj, math, tonumber, type;

-- take parameters.
--[==[
	PI =
	{
		width:       number?,
		height:      number?,
		align_x:     number?,
		align_y:     number?,
		line:        number?,
		color:       number?,
		color_back:  number?,
		alpha_back:  number?,
		head_len:    number?,
		head_width:  number?,
		shaft:       number?,
		double_head: boolean|number|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end

width       = tonumber(PI.width)      or width;
height      = tonumber(PI.height)     or height;
align_x     = tonumber(PI.align_x)    or align_x;
align_y     = tonumber(PI.align_y)    or align_y;
line        = tonumber(PI.line)       or line;
color       = tonumber(PI.color)      or color;
color_back  = tonumber(PI.color_back) or color_back;
alpha_back  = tonumber(PI.alpha_back) or alpha_back;
head_len    = tonumber(PI.head_len)   or head_len;
head_width  = tonumber(PI.head_width) or head_width;
shaft       = tonumber(PI.shaft)      or shaft;
double_head = as_bool(PI.double_head, double_head ~= 0);

-- normalize parameters.
width   = math.max(math.floor(0.5 + width), 0);
height  = math.max(math.floor(0.5 + height), 0);
align_x  = math.min(math.max(align_x / 100, -1), 1);
align_y  = math.min(math.max(align_y / 100, -1), 1);
line    = math.max(math.floor(0.5 + line), 0);
color       = math.floor(0.5 + color) % 2 ^ 24;
color_back  = math.floor(0.5 + color_back) % 2 ^ 24;
alpha_back  = math.min(math.max(1 - alpha_back / 100, 0), 1);

-- constrain shape ratios
local head_ratio  = math.min(math.max(head_len   / 100, 0), 1);  -- 0..1 of width
local head_wratio = math.min(math.max(head_width / 100, 0), 1);  -- 0..1 of height
local shaft_ratio = math.min(math.max(shaft      / 100, 0), 1);  -- 0..1 of height

if width <= 0 or height <= 0 then return end

-- Prepare temporary render target
obj.setoption("drawtarget", "tempbuffer", width, height);
obj.load("tempbuffer");
obj.cx, obj.cy = -width * align_x / 2, -height * align_y / 2;
if line <= 0 and alpha_back <= 0 then return end

-- Normalized constants for shader
local r_x = (width  > 0) and 2 / width  or 0;
local r_y = (height > 0) and 2 / height or 0;
local hn  = 2 * head_ratio;              -- 0..2
local ly  = shaft_ratio;                 -- 0..1
local hb  = head_wratio;                 -- 0..1
if double_head then hn = math.min(hn, 0.99) else hn = math.min(hn, 1.99) end

-- Background pass (fill)
obj.clearbuffer("object", color_back);
obj.pixelshader("carve", "object", nil, { r_x, r_y; hn; ly; hb; double_head and 1 or 0; }, "mask");

-- If no outline, just apply alpha and finish
if line <= 0 then
	if alpha_back < 1 then
		obj.effect("透明度適用@Basic_S", "透明度", 100 * (1 - alpha_back));
	end
	return
end

-- Store background to temp for later composition
obj.copybuffer("tempbuffer", "object");

-- Outline pass (chrome)
obj.clearbuffer("object");
obj.pixelshader("carve", "object", nil, { r_x, r_y; hn; ly; hb; double_head and 1 or 0; }, "mask");
obj.effect("縁取りα@Basic_S", "サイズ", -line, "ぼかし", 0, "縁色", color, "前景透明度", 100);

-- Composite outline over background with background alpha control
obj.pixelshader("combine", "object", { "object", "tempbuffer" }, { alpha_back; });
